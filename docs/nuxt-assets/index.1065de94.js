import{V as w,B as C,a as _,S as P,C as M,P as z,b as B,O as A,u as D,c as R,d as g,M as S,e as E}from"./camera.778392bf.js";import{o as U,Q as O,F as x,R as k,S as T,j as F,k as I,l as V}from"./entry.9e1091cc.js";import{u as L}from"./tweakpane.8044cfb2.js";import{l as N}from"./assets.e623ba5f.js";import"./tweakpane.4e5e1789.js";const j={count:512*512,pointSize:1,opacity:1};function H(h={}){const t={...j,...h},l=t.count;let n,i,s;m();const o=new w;return{config:t,mesh:s,origin:o,update:d};function d(r){}function m(){const r={value:null};N("/textures/sphere_normal.jpg").then(a=>{a.flipY=!1,r.value=a}),n=new C;const c=new Float32Array(l*3),e=new Float32Array(l*4);for(let a=0;a<l*3;a+=3)q().toArray(c,a);for(let a=0;a<l*4;a+=4)e[a]=Math.random(),e[a+1]=Math.random(),e[a+2]=Math.random(),e[a+3]=1;n.setAttribute("position",new _(c,3)),n.setAttribute("color",new _(e,4));const u=B.lights_fragment_begin.replaceAll("RE_Direct( directLight, geometry, material, reflectedLight );","\n        RE_Direct( directLight, geometry, material, reflectedLight );\n        #if defined( SUBSURFACE )\n          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\n        #endif\n      ");i=new P({transparent:!0,vertexColors:!0,lights:!0,uniforms:{uPointSize:{value:t.pointSize},uOpacity:{value:t.opacity},uNormalMap:r,ambientLightColor:{value:null},lightProbe:{value:null},directionalLights:{value:null},directionalLightShadows:{value:null},spotLights:{value:null},spotLightShadows:{value:null},rectAreaLights:{value:null},ltc_1:{value:null},ltc_2:{value:null},pointLights:{value:null},pointLightShadows:{value:null},hemisphereLights:{value:null},directionalShadowMap:{value:null},directionalShadowMatrix:{value:null},spotShadowMap:{value:null},spotLightMatrix:{value:null},spotLightMap:{value:null},pointShadowMap:{value:null},pointShadowMatrix:{value:null},thicknessColor:{value:new M(16777215)},thicknessDistortion:{value:.5},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:2},thicknessScale:{value:10}},vertexShader:"\n        uniform float uPointSize;\n        varying vec4 vCol;\n        varying vec3 vViewPosition;\n\n        void main() {\n          vCol = color;\n          vec3 transformed = vec3(position);\n          vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n          vViewPosition = - mvPosition.xyz;\n          gl_Position = projectionMatrix * mvPosition;\n          gl_PointSize = uPointSize * ( 10.0 / -mvPosition.z );\n        }\n      ",fragmentShader:"\n        #define SUBSURFACE\n\n        uniform float uOpacity;\n        uniform sampler2D uNormalMap;\n        uniform mat3 normalMatrix;\n\n        uniform float thicknessPower;\n        uniform float thicknessScale;\n        uniform float thicknessDistortion;\n        uniform float thicknessAmbient;\n        uniform float thicknessAttenuation;\n        uniform vec3 thicknessColor;\n\n        varying vec4 vCol;\n\n        #include <common>\n        #include <bsdfs>\n        #include <lights_pars_begin>\n        #include <lights_phong_pars_fragment>\n\n        void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\n          #ifdef USE_COLOR\n            vec3 thickness = vCol.rgb * thicknessColor;\n          #else\n            vec3 thickness = thicknessColor;\n          #endif\n          vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\n          float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n          vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\n          reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n        }\n\n        void main() {\n          float dist = length(gl_PointCoord - 0.5);\n          if (dist > 0.49) discard;\n\n          ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n          vec3 totalEmissiveRadiance = vec3(0, 0, 0) ; // vCol.rgb;\n\n          vec2 vUv = gl_PointCoord;\n          vec3 normal = texture2D(uNormalMap, gl_PointCoord).xyz * 2.0 - 1.0;\n          normal = normalize( normal );\n\n          BlinnPhongMaterial material;\n          material.diffuseColor = vCol.rgb;\n          material.specularColor = vec3(0.0, 0.0, 0.0);\n          material.specularShininess = 30.0;\n          material.specularStrength = 1.0;\n\n          ".concat(u,"\n          // #include <lights_fragment_begin>\n          #include <lights_fragment_end>\n          vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n          gl_FragColor = vec4(outgoingLight, uOpacity);\n        }\n      ")}),s=new z(n,i)}}function q(){const h=Math.random(),t=Math.random(),l=h*2*Math.PI,n=Math.acos(2*t-1),i=Math.cbrt(Math.random()),s=Math.sin(l),o=Math.cos(l),d=Math.sin(n),m=Math.cos(n),r=i*d*o,c=i*d*s,e=i*m;return new w(r,c,e)}const G={class:"test"},Q=V("canvas",{id:"webgl-test"},null,-1),Y=[Q],Z={__name:"index",setup(h){let t,l;const n=new A;let i,s,o;U(()=>{O(async()=>{t=D({id:"webgl-test",size:"window",alpha:!0,postprocessing:{effects:[{EffectClass:E,args:[{mipmapBlur:!0,luminanceThreshold:0,luminanceSmoothing:.05,intensity:2,radius:.25}]}]}}),t.cameraMaxAspect=1.7,t.camera.position.set(0,0,2),t.camera.lookAt(0,0,0),l=R(t.camera,t.canvas);const e=.5,u=.5,a=new g(6328575,e);a.position.set(-1,0,0).multiplyScalar(u),n.add(a);const f=new g(16748640,e);f.position.set(1,0,0).multiplyScalar(u),n.add(f);const p=new g(6356880,e);p.position.set(0,-1,0).multiplyScalar(u),n.add(p);const v=new g(16736511,e);v.position.set(0,1,0).multiplyScalar(u),n.add(v),t.scene.add(n);const y=S.clamp(x().query.count||262144,256,4194304),b=S.clamp(x().query.pointSize||1,.1,10);i=H({count:y,pointSize:b}),t.scene.add(i.mesh),d(),t.on("update",r)}),k().on("device.pointermove",m),k().on("device.resize",c)});function d(){s=L({title:"Postprocessing"}),s.addBinding(t.postprocessing,"bloomIntensity",{min:0,max:10,step:.01}),s.addBinding(t.postprocessing,"bloomRadius",{min:0,max:1,step:.001}),s.addBinding(t.postprocessing,"bloomLuminanceThreshold",{min:0,max:1,step:.001}),s.addBinding(t.postprocessing,"bloomLuminanceSmoothing",{min:0,max:1,step:.001}),o=L({title:"Misc",expanded:!1}),o.addBinding(n.scale,"x",{label:"lights scale",step:.1,min:0,max:2}).on("change",({value:e})=>{n.scale.y=e,n.scale.z=e}),o.addBinding(i.mesh.scale,"x",{label:"particles scale",step:.1,min:0,max:2}).on("change",({value:e})=>{i.mesh.scale.y=e,i.mesh.scale.z=e}),o.addBinding(i.mesh.material.uniforms.uPointSize,"value",{label:"pointSize",step:1e-4,min:0,max:10}),o.addBinding(i.mesh.material.uniforms.thicknessDistortion,"value",{label:"thicknessDistortion",step:1e-4,min:0,max:1}),o.addBinding(i.mesh.material.uniforms.thicknessAmbient,"value",{label:"thicknessAmbient",step:1e-4,min:0,max:1}),o.addBinding(i.mesh.material.uniforms.thicknessAttenuation,"value",{label:"thicknessAttenuation",step:1e-4,min:0,max:1}),o.addBinding(i.mesh.material.uniforms.thicknessPower,"value",{label:"thicknessPower",step:1e-4,min:0,max:50}),o.addBinding(i.mesh.material.uniforms.thicknessScale,"value",{label:"thicknessScale",step:1e-4,min:0,max:50}),o.addBinding({thicknessColor:i.mesh.material.uniforms.thicknessColor.value.getHex()},"thicknessColor",{view:"color"}).on("change",({value:e})=>{i.mesh.material.uniforms.thicknessColor.value.set(e)})}function m(e){}function r(e){l.update(),i.mesh.rotation.x+=e.delta*.01,i.mesh.rotation.y+=e.delta*.016,i.mesh.rotation.z+=e.delta*.007,n.rotation.x+=e.delta*.4,n.rotation.y+=e.delta*.25,n.rotation.z+=e.delta*.65}function c(){t&&t.resize()}return T(()=>{s==null||s.dispose(),o==null||o.dispose(),l&&l.dispose(),t&&(t.off("update",r),t.off("resize",c),t.dispose())}),(e,u)=>(F(),I("div",G,Y))}};export{Z as default};
