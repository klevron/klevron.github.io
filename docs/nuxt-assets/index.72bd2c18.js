import{f as Y,g as Z,h as X,i as ee,S as G,W as ne,R as F,D as te,F as V,N as A,j as k,C as D,V as M,H as ie,B as oe,a as L,P as ae,M as re,b as se,k as le,l as ce,u as ue,c as de,A as ve,m as U,e as pe}from"./camera.778392bf.js";import{o as ge,Q as fe,R as B,S as he,j as me,k as xe,l as ye}from"./entry.9e1091cc.js";import{u as we}from"./tweakpane.8044cfb2.js";import{l as Te}from"./assets.e623ba5f.js";import"./tweakpane.4e5e1789.js";class be{constructor(i,o,n){this.variables=[],this.currentTextureIndex=0;let a=V;const l=new Y,x=new Z;x.position.z=1;const m={passThruTexture:{value:null}},c=R(g(),m),d=new X(new ee(2,2),c);l.add(d),this.setDataType=function(t){return a=t,this},this.addVariable=function(t,e,r){const p=this.createShaderMaterial(e),s={name:t,initialValueTexture:r,material:p,dependencies:null,renderTargets:[],wrapS:null,wrapT:null,minFilter:A,magFilter:A};return this.variables.push(s),s},this.setVariableDependencies=function(t,e){t.dependencies=e},this.init=function(){if(n.capabilities.isWebGL2===!1&&n.extensions.has("OES_texture_float")===!1)return"No OES_texture_float support for float textures.";if(n.capabilities.maxVertexTextures===0)return"No support for vertex shader textures.";for(let t=0;t<this.variables.length;t++){const e=this.variables[t];e.renderTargets[0]=this.createRenderTarget(i,o,e.wrapS,e.wrapT,e.minFilter,e.magFilter),e.renderTargets[1]=this.createRenderTarget(i,o,e.wrapS,e.wrapT,e.minFilter,e.magFilter),this.renderTexture(e.initialValueTexture,e.renderTargets[0]),this.renderTexture(e.initialValueTexture,e.renderTargets[1]);const r=e.material,p=r.uniforms;if(e.dependencies!==null)for(let s=0;s<e.dependencies.length;s++){const f=e.dependencies[s];if(f.name!==e.name){let y=!1;for(let w=0;w<this.variables.length;w++)if(f.name===this.variables[w].name){y=!0;break}if(!y)return"Variable dependency not found. Variable="+e.name+", dependency="+f.name}p[f.name]={value:null},r.fragmentShader="\nuniform sampler2D "+f.name+";\n"+r.fragmentShader}}return this.currentTextureIndex=0,null},this.compute=function(){const t=this.currentTextureIndex,e=this.currentTextureIndex===0?1:0;for(let r=0,p=this.variables.length;r<p;r++){const s=this.variables[r];if(s.dependencies!==null){const f=s.material.uniforms;for(let y=0,w=s.dependencies.length;y<w;y++){const I=s.dependencies[y];f[I.name].value=I.renderTargets[t].texture}}this.doRenderTarget(s.material,s.renderTargets[e])}this.currentTextureIndex=e},this.getCurrentRenderTarget=function(t){return t.renderTargets[this.currentTextureIndex]},this.getAlternateRenderTarget=function(t){return t.renderTargets[this.currentTextureIndex===0?1:0]},this.dispose=function(){d.geometry.dispose(),d.material.dispose();const t=this.variables;for(let e=0;e<t.length;e++){const r=t[e];r.initialValueTexture&&r.initialValueTexture.dispose();const p=r.renderTargets;for(let s=0;s<p.length;s++)p[s].dispose()}};function b(t){t.defines.resolution="vec2( "+i.toFixed(1)+", "+o.toFixed(1)+" )"}this.addResolutionDefine=b;function R(t,e){e=e||{};const r=new G({name:"GPUComputationShader",uniforms:e,vertexShader:P(),fragmentShader:t});return b(r),r}this.createShaderMaterial=R,this.createRenderTarget=function(t,e,r,p,s,f){return t=t||i,e=e||o,r=r||k,p=p||k,s=s||A,f=f||A,new ne(t,e,{wrapS:r,wrapT:p,minFilter:s,magFilter:f,format:F,type:a,depthBuffer:!1})},this.createTexture=function(){const t=new Float32Array(i*o*4),e=new te(t,i,o,F,V);return e.needsUpdate=!0,e},this.renderTexture=function(t,e){m.passThruTexture.value=t,this.doRenderTarget(c,e),m.passThruTexture.value=null},this.doRenderTarget=function(t,e){const r=n.getRenderTarget(),p=n.xr.enabled,s=n.shadowMap.autoUpdate;n.xr.enabled=!1,n.shadowMap.autoUpdate=!1,d.material=t,n.setRenderTarget(e),n.render(l,x),d.material=c,n.xr.enabled=p,n.shadowMap.autoUpdate=s,n.setRenderTarget(r)};function P(){return"void main()	{\n\n	gl_Position = vec4( position, 1.0 );\n\n}\n"}function g(){return"uniform sampler2D passThruTexture;\n\nvoid main() {\n\n	vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n	gl_FragColor = texture2D( passThruTexture, uv );\n\n}\n"}}}function q(z){let i=[];n(z);const o=new D;return{setColors:n,getColorAt:a};function n(l){i=[],l.forEach(x=>{i.push(new D(x))})}function a(l){const x=Math.max(0,Math.min(1,l))*(z.length-1),m=Math.floor(x),c=i[m];if(m>=z.length-1)return c.clone();const d=x-m,b=i[m+1];return o.r=c.r+d*(b.r-c.r),o.g=c.g+d*(b.g-c.g),o.b=c.b+d*(b.b-c.b),o.clone()}}const Se='//\n// psrdnoise3.glsl\n//\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\n// and Ian McEwan (ijm567@gmail.com)\n// Version 2021-12-02, published under the MIT license (see below)\n//\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the "Software"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n//\n\n//\n// Periodic (tiling) 3-D simplex noise (tetrahedral lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n//\n// This is (yet) another variation on simplex noise. Unlike previous\n// implementations, the grid is axis-aligned to permit rectangular tiling.\n// The noise pattern can be made to tile seamlessly to any integer periods\n// up to 289 units in the x, y and z directions. Specifying a longer\n// period than 289 will result in errors in the noise field.\n//\n// This particular version of 3-D noise also implements animation by rotating\n// the generating gradient at each lattice point around a pseudo-random axis.\n// The rotating gradients give the appearance of a swirling motion, and\n// can serve a similar purpose for animation as motion along the fourth\n// dimension in 4-D noise. \n//\n// The rotating gradients in conjunction with the built-in ability to\n// compute exact analytic derivatives allow for "flow noise" effects\n// as presented by Ken Perlin and Fabrice Neyret.\n//\n\n// Use Perlin\'s rotated grid instead of the new tiling grid?\n// Enabling this adds about 1% to the execution time and\n// requires all periods to be multiples of 3. Other\n// integer periods can be specified, but when not evenly\n// divisible by 3, the actual period will be 3 times longer.\n// Take care not to overstep the maximum allowed period (288).\n//#define PERLINGRID\n\n// Enable faster gradient rotations?\n// Enabling this saves about 10% on execution time,\n// but the function will not run faster for alpha = 0.\n//#define FASTROTATION\n\n\n// Permutation polynomial for the hash value\nvec4 permute(vec4 x) {\n     vec4 xm = mod(x, 289.0);\n     return mod(((xm*34.0)+10.0)*xm, 289.0);\n}\n\n//\n// 3-D tiling simplex noise with rotating gradients and first order\n// analytical derivatives.\n// "vec3 x" is the point (x,y,z) to evaluate\n// "vec3 period" is the desired periods along x,y,z, up to 289.\n// (If Perlin\'s grid is used, multiples of 3 up to 288 are allowed.)\n// "float alpha" is the rotation (in radians) for the swirling gradients.\n// The "float" return value is the noise value, and\n// the "out vec3 gradient" argument returns the x,y,z partial derivatives.\n//\n// The function executes 15-20% faster if alpha is constant == 0.0\n// across all fragments being executed in parallel.\n// (This speedup will not happen if FASTROTATION is enabled. Do not specify\n// FASTROTATION if you are not actually going to use the rotation.)\n//\n// Setting any period to 0.0 or a negative value will skip the periodic\n// wrap for that dimension. Setting all periods to 0.0 makes the function\n// execute 10-15% faster.\n//\n// Not using the return value for the gradient will make the compiler\n// eliminate the code for computing it. This speeds up the function by\n// around 10%.\n//\nfloat psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)\n{\n\n#ifndef PERLINGRID\n  // Transformation matrices for the axis-aligned simplex grid\n  const mat3 M = mat3(0.0, 1.0, 1.0,\n                      1.0, 0.0, 1.0,\n                      1.0, 1.0, 0.0);\n\n  const mat3 Mi = mat3(-0.5, 0.5, 0.5,\n                        0.5,-0.5, 0.5,\n                        0.5, 0.5,-0.5);\n#endif\n\n  vec3 uvw;\n\n  // Transform to simplex space (tetrahedral grid)\n#ifndef PERLINGRID\n  // Use matrix multiplication, let the compiler optimise\n  uvw = M * x;\n#else\n  // Optimised transformation to uvw (slightly faster than\n  // the equivalent matrix multiplication on most platforms)\n  uvw = x + dot(x, vec3(1.0/3.0));\n#endif\n\n  // Determine which simplex we\'re in, i0 is the "base corner"\n  vec3 i0 = floor(uvw);\n  vec3 f0 = fract(uvw); // coords within "skewed cube"\n\n  // To determine which simplex corners are closest, rank order the\n  // magnitudes of u,v,w, resolving ties in priority order u,v,w,\n  // and traverse the four corners from largest to smallest magnitude.\n  // o1, o2 are offsets in simplex space to the 2nd and 3rd corners.\n  vec3 g_ = step(f0.xyx, f0.yzz); // Makes comparison "less-than"\n  vec3 l_ = 1.0 - g_;             // complement is "greater-or-equal"\n  vec3 g = vec3(l_.z, g_.xy);\n  vec3 l = vec3(l_.xy, g_.z);\n  vec3 o1 = min( g, l );\n  vec3 o2 = max( g, l );\n\n  // Enumerate the remaining simplex corners\n  vec3 i1 = i0 + o1;\n  vec3 i2 = i0 + o2;\n  vec3 i3 = i0 + vec3(1.0);\n\n  vec3 v0, v1, v2, v3;\n\n  // Transform the corners back to texture space\n#ifndef PERLINGRID\n  v0 = Mi * i0;\n  v1 = Mi * i1;\n  v2 = Mi * i2;\n  v3 = Mi * i3;\n#else\n  // Optimised transformation (mostly slightly faster than a matrix)\n  v0 = i0 - dot(i0, vec3(1.0/6.0));\n  v1 = i1 - dot(i1, vec3(1.0/6.0));\n  v2 = i2 - dot(i2, vec3(1.0/6.0));\n  v3 = i3 - dot(i3, vec3(1.0/6.0));\n#endif\n\n  // Compute vectors to each of the simplex corners\n  vec3 x0 = x - v0;\n  vec3 x1 = x - v1;\n  vec3 x2 = x - v2;\n  vec3 x3 = x - v3;\n\n  if(any(greaterThan(period, vec3(0.0)))) {\n    // Wrap to periods and transform back to simplex space\n    vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);\n    vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);\n    vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);\n	// Wrap to periods where specified\n	if(period.x > 0.0) vx = mod(vx, period.x);\n	if(period.y > 0.0) vy = mod(vy, period.y);\n	if(period.z > 0.0) vz = mod(vz, period.z);\n    // Transform back\n#ifndef PERLINGRID\n    i0 = M * vec3(vx.x, vy.x, vz.x);\n    i1 = M * vec3(vx.y, vy.y, vz.y);\n    i2 = M * vec3(vx.z, vy.z, vz.z);\n    i3 = M * vec3(vx.w, vy.w, vz.w);\n#else\n    v0 = vec3(vx.x, vy.x, vz.x);\n    v1 = vec3(vx.y, vy.y, vz.y);\n    v2 = vec3(vx.z, vy.z, vz.z);\n    v3 = vec3(vx.w, vy.w, vz.w);\n    // Transform wrapped coordinates back to uvw\n    i0 = v0 + dot(v0, vec3(1.0/3.0));\n    i1 = v1 + dot(v1, vec3(1.0/3.0));\n    i2 = v2 + dot(v2, vec3(1.0/3.0));\n    i3 = v3 + dot(v3, vec3(1.0/3.0));\n#endif\n	// Fix rounding errors\n    i0 = floor(i0 + 0.5);\n    i1 = floor(i1 + 0.5);\n    i2 = floor(i2 + 0.5);\n    i3 = floor(i3 + 0.5);\n  }\n\n  // Compute one pseudo-random hash value for each corner\n  vec4 hash = permute( permute( permute( \n              vec4(i0.z, i1.z, i2.z, i3.z ))\n            + vec4(i0.y, i1.y, i2.y, i3.y ))\n            + vec4(i0.x, i1.x, i2.x, i3.x ));\n\n  // Compute generating gradients from a Fibonacci spiral on the unit sphere\n  vec4 theta = hash * 3.883222077;  // 2*pi/golden ratio\n  vec4 sz    = hash * -0.006920415 + 0.996539792; // 1-(hash+0.5)*2/289\n  vec4 psi   = hash * 0.108705628 ; // 10*pi/289, chosen to avoid correlation\n\n  vec4 Ct = cos(theta);\n  vec4 St = sin(theta);\n  vec4 sz_prime = sqrt( 1.0 - sz*sz ); // s is a point on a unit fib-sphere\n\n  vec4 gx, gy, gz;\n\n  // Rotate gradients by angle alpha around a pseudo-random ortogonal axis\n#ifdef FASTROTATION\n  // Fast algorithm, but without dynamic shortcut for alpha = 0\n  vec4 qx = St;         // q\' = norm ( cross(s, n) )  on the equator\n  vec4 qy = -Ct; \n  vec4 qz = vec4(0.0);\n\n  vec4 px =  sz * qy;   // p\' = cross(q, s)\n  vec4 py = -sz * qx;\n  vec4 pz = sz_prime;\n\n  psi += alpha;         // psi and alpha in the same plane\n  vec4 Sa = sin(psi);\n  vec4 Ca = cos(psi);\n\n  gx = Ca * px + Sa * qx;\n  gy = Ca * py + Sa * qy;\n  gz = Ca * pz + Sa * qz;\n#else\n  // Slightly slower algorithm, but with g = s for alpha = 0, and a\n  // useful conditional speedup for alpha = 0 across all fragments\n  if(alpha != 0.0) {\n    vec4 Sp = sin(psi);          // q\' from psi on equator\n    vec4 Cp = cos(psi);\n\n    vec4 px = Ct * sz_prime;     // px = sx\n    vec4 py = St * sz_prime;     // py = sy\n    vec4 pz = sz;\n\n    vec4 Ctp = St*Sp - Ct*Cp;    // q = (rotate( cross(s,n), dot(s,n))(q\')\n    vec4 qx = mix( Ctp*St, Sp, sz);\n    vec4 qy = mix(-Ctp*Ct, Cp, sz);\n    vec4 qz = -(py*Cp + px*Sp);\n\n    vec4 Sa = vec4(sin(alpha));       // psi and alpha in different planes\n    vec4 Ca = vec4(cos(alpha));\n\n    gx = Ca * px + Sa * qx;\n    gy = Ca * py + Sa * qy;\n    gz = Ca * pz + Sa * qz;\n  }\n  else {\n    gx = Ct * sz_prime;  // alpha = 0, use s directly as gradient\n    gy = St * sz_prime;\n    gz = sz;  \n  }\n#endif\n\n  // Reorganize for dot products below\n  vec3 g0 = vec3(gx.x, gy.x, gz.x);\n  vec3 g1 = vec3(gx.y, gy.y, gz.y);\n  vec3 g2 = vec3(gx.z, gy.z, gz.z);\n  vec3 g3 = vec3(gx.w, gy.w, gz.w);\n\n  // Radial decay with distance from each simplex corner\n  vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  w = max(w, 0.0);\n  vec4 w2 = w * w;\n  vec4 w3 = w2 * w;\n\n  // The value of the linear ramp from each of the corners\n  vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));\n\n  // Multiply by the radial decay and sum up the noise value\n  float n = dot(w3, gdotx);\n\n  // Compute the first order partial derivatives\n  vec4 dw = -6.0 * w2 * gdotx;\n  vec3 dn0 = w3.x * g0 + dw.x * x0;\n  vec3 dn1 = w3.y * g1 + dw.y * x1;\n  vec3 dn2 = w3.z * g2 + dw.z * x2;\n  vec3 dn3 = w3.w * g3 + dw.w * x3;\n  gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);\n\n  // Scale the return value to fit nicely into the range [-1,1]\n  return 39.5 * n;\n}',{randFloat:H,randFloatSpread:O}=re,Ce={gpgpuSize:256,colors:[1395874,6328575],color:0,velocity:.5,coordScale:.5,noiseIntensity:.001,noiseTimeCoef:.25,pointSize:10,pointDecay:.0025,opacity:1};function ze(z,i={}){const o={...Ce,...i},n=o.gpgpuSize,a=n*n;let l,x,m,c,d;const b={value:0},R={value:o.velocity},P={value:o.coordScale},g={value:o.noiseIntensity},t={value:o.pointSize},e={value:o.pointDecay},r={value:o.opacity},p={value:new D(o.color)},s={value:new M},f={value:null},y={uTime:b,uVelocity:R,uCoordScale:P,uNoiseIntensity:g,uPointSize:t,uPointDecay:e,uOpacity:r,uColor:p,uOrigin:s,uNormalMap:f};let w,I,N;K(z),$();const W=new M;return{config:o,mesh:N,origin:W,uniforms:y,update:j,updateColors:Q};function j(h){b.value+=h.delta*o.noiseTimeCoef,l.compute(),I.uniforms.texturePosition.value=l.getCurrentRenderTarget(d).texture,I.uniforms.textureVelocity.value=l.getCurrentRenderTarget(c).texture}function K(h){l=new be(n,n,h),h.capabilities.isWebGL2||l.setDataType(ie),x=l.createTexture(),m=l.createTexture(),l.createTexture(),J(x,m),c=l.addVariable("textureVelocity","\n      ".concat(Se,"\n      uniform float uTime;\n      uniform float uCoordScale;\n      uniform float uNoiseIntensity;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        if (pos.w < 0.0) {\n          vel.x = 0.0;\n          vel.y = 0.0;\n          vel.z = 0.0;\n        } else {\n          vec3 grad;\n          vec3 p = vec3(0.0);\n          float n = psrdnoise(pos.xyz * uCoordScale, p, uTime, grad);\n          vel.xyz += grad * uNoiseIntensity * pos.w;\n        }\n        gl_FragColor = vel;\n      }\n    "),m),d=l.addVariable("texturePosition","\n      uniform float uVelocity;\n      uniform float uPointDecay;\n      uniform vec3 uOrigin;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        if (pos.w < 0.0) { pos.w = vel.w; }\n        pos.w -= uPointDecay;\n        if (pos.w < 0.0) {\n          pos.xyz = uOrigin.xyz;\n        } else {\n          pos.xyz += uVelocity * vel.xyz;\n        }\n        gl_FragColor = pos;\n      }\n    ",x),l.setVariableDependencies(c,[d,c]),l.setVariableDependencies(d,[d,c]),Object.keys(y).forEach(u=>{c.material.uniforms[u]=y[u],d.material.uniforms[u]=y[u]});const C=l.init();C!==null&&console.error(C)}function $(){Te("/textures/sphere_normal.jpg").then(v=>{v.flipY=!1,f.value=v}),w=new oe;const h=new Float32Array(a*3),C=new Float32Array(a*2),u=new Float32Array(a*3);for(let v=0;v<a*3;v+=3)h[v]=0,h[v+1]=0,h[v+2]=0;let S=0;for(let v=0;v<n;v++)for(let _=0;_<n;_++)C[S++]=_/(n-1),C[S++]=v/(n-1);const T=q(o.colors);for(let v=0;v<a*3;v+=3){const _=T.getColorAt(Math.random());u[v]=_.r,u[v+1]=_.g,u[v+2]=_.b}w.setAttribute("position",new L(h,3)),w.setAttribute("uv",new L(C,2)),w.setAttribute("color",new L(u,3));const E=se.lights_fragment_begin.replaceAll("RE_Direct( directLight, geometry, material, reflectedLight );","\n        RE_Direct( directLight, geometry, material, reflectedLight );\n        #if defined( SUBSURFACE )\n          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\n        #endif\n      ");I=new G({lights:!0,transparent:!0,vertexColors:!0,uniforms:{texturePosition:{value:null},textureVelocity:{value:null},uPointSize:t,uOpacity:r,uColor:p,uNormalMap:f,ambientLightColor:{value:null},lightProbe:{value:null},directionalLights:{value:null},directionalLightShadows:{value:null},spotLights:{value:null},spotLightShadows:{value:null},rectAreaLights:{value:null},ltc_1:{value:null},ltc_2:{value:null},pointLights:{value:null},pointLightShadows:{value:null},hemisphereLights:{value:null},directionalShadowMap:{value:null},directionalShadowMatrix:{value:null},spotShadowMap:{value:null},spotLightMatrix:{value:null},spotLightMap:{value:null},pointShadowMap:{value:null},pointShadowMatrix:{value:null},thicknessColor:{value:new D(16777215)},thicknessDistortion:{value:.5},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:5},thicknessScale:{value:10}},vertexShader:"\n        uniform sampler2D texturePosition;\n        uniform sampler2D textureVelocity;\n        uniform float uPointSize;\n\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying vec3 vCol;\n        varying vec3 vViewPosition;\n\n        void main() {\n          vCol = color;\n          vPos = texture2D(texturePosition, uv);\n          vVel = texture2D(textureVelocity, uv);\n          vec4 mvPosition = modelViewMatrix * vec4(vPos.xyz, 1.0);\n          vViewPosition = - mvPosition.xyz;\n          gl_PointSize = ( 10.0 / -mvPosition.z ) * vPos.w * (vVel.w + 0.5) * uPointSize;\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      ",fragmentShader:"\n        #define SUBSURFACE\n\n        uniform float uOpacity;\n        uniform vec3 uColor;\n        uniform sampler2D uNormalMap;\n        uniform mat3 normalMatrix;\n\n        uniform float thicknessPower;\n        uniform float thicknessScale;\n        uniform float thicknessDistortion;\n        uniform float thicknessAmbient;\n        uniform float thicknessAttenuation;\n        uniform vec3 thicknessColor;\n\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying vec3 vCol;\n               \n        #include <common>\n        #include <bsdfs>\n        #include <lights_pars_begin>\n        #include <lights_phong_pars_fragment>\n\n        void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\n          #ifdef USE_COLOR\n            vec3 thickness = vCol.rgb * thicknessColor;\n          #else\n            vec3 thickness = thicknessColor;\n          #endif\n          vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\n          float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n          vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\n          reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n        }\n\n        void main() {\n          float dist = length(gl_PointCoord - 0.5);\n          if (dist > 0.5) discard;\n\n          ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n          vec3 totalEmissiveRadiance = vec3(0, 0, 0) ; // vCol.rgb;\n\n          vec2 vUv = gl_PointCoord;\n          vec3 normal = texture2D(uNormalMap, gl_PointCoord).xyz * 2.0 - 1.0;\n          normal = normalize( normal );\n\n          BlinnPhongMaterial material;\n          material.diffuseColor = vCol.rgb;\n          material.specularColor = vec3(0.0, 0.0, 0.0);\n          material.specularShininess = 30.0;\n          material.specularStrength = 1.0;\n\n          ".concat(E,"\n          // #include <lights_fragment_begin>\n          #include <lights_fragment_end>\n          vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n          gl_FragColor = vec4(outgoingLight, 1.0);\n        }\n      ")}),N=new ae(w,I)}function Q(){const h=w.getAttribute("color"),C=q(o.colors);for(let u=0;u<a*3;u+=3){const S=C.getColorAt(Math.random());h.array[u]=S.r,h.array[u+1]=S.g,h.array[u+2]=S.b}h.needsUpdate=!0}function J(h,C){const u=h.image.data,S=C.image.data;for(let T=0,E=u.length;T<E;T+=4)u[T+0]=O(1),u[T+1]=O(1),u[T+2]=O(1),u[T+3]=H(.001,1),S[T+0]=0,S[T+1]=0,S[T+2]=0,S[T+3]=H(.001,1)}}const Re={class:"test"},Ie=ye("canvas",{id:"webgl-test"},null,-1),_e=[Ie],Oe={__name:"index",setup(z){let i,o,n,a;const l={followMouse:!1},x=new le,m=new ce,c=new M;ge(()=>{fe(()=>{i=ue({id:"webgl-test",size:"window",postprocessing:{effects:[{EffectClass:pe,args:[{mipmapBlur:!0,luminanceThreshold:0,luminanceSmoothing:.05,intensity:1.25,radius:.25}]}]}}),i.camera.position.set(0,0,10),i.camera.lookAt(0,0,0),o=de(i.camera,i.canvas);const g=new ve(16777215,.25);i.scene.add(g);const t=new U(255,10);t.position.set(1,1,0),i.scene.add(t);const e=new U(16711680,10);e.position.set(-1,-1,0),i.scene.add(e),n=ze(i.renderer),i.scene.add(n.mesh),d(),i.on("update",R)}),B().on("device.pointermove",b),B().on("device.resize",P)});function d(){a=we({title:"Debug",expanded:!0}),a.addBinding(l,"followMouse").on("change",({value:g})=>{g||c.set(0,0,0)}),a.addBinding({color1:n.config.colors[0]},"color1",{view:"color"}).on("change",({value:g})=>{n.config.colors[0]=g,n.updateColors()}),a.addBinding({color2:n.config.colors[1]},"color2",{view:"color"}).on("change",({value:g})=>{n.config.colors[1]=g,n.updateColors()}),a.addBinding(n.uniforms.uVelocity,"value",{label:"velocity",step:1e-4,min:0,max:1}),a.addBinding(n.uniforms.uPointSize,"value",{label:"size",step:.001,min:0,max:50}),a.addBinding(n.uniforms.uPointDecay,"value",{label:"decay",step:1e-5,min:1e-4,max:.01}),a.addBinding(n.config,"noiseTimeCoef",{label:"noise time",step:.001,min:0,max:1}),a.addBinding(n.uniforms.uCoordScale,"value",{label:"noise scale",step:.001,min:0,max:2}),a.addBinding(n.uniforms.uNoiseIntensity,"value",{label:"noise intensity",step:1e-4,min:0,max:.01})}function b(g){l.followMouse&&(i.camera.getWorldDirection(m.normal),x.setFromCamera(g.pointer.relative,i.camera),x.ray.intersectPlane(m,c))}function R(g){o.update(),n.update(g)}function P(){i&&i.resize()}return he(()=>{a==null||a.dispose(),o&&o.dispose(),i&&(i.off("update",R),i.off("resize",P),i.dispose())}),(g,t)=>(me(),xe("div",Re,_e))}};export{Oe as default};
