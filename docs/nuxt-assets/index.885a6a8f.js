import{S as ne,C as te,M as ie,P as ae,a as j,W as oe,R as F,D as re,F as V,N as D,b as B,c as k,V as N,H as se,B as le,d as O,e as E,f as ce,g as ue,O as de,h as ve,i as pe,u as me,j as ge,k as L,l as he}from"./camera.79f4e44e.js";import{o as fe,Q as xe,F as U,R as q,S as ye,j as we,k as Te,l as be}from"./entry.af5b1f20.js";import{u as H}from"./tweakpane.8044cfb2.js";import{l as Se}from"./assets.a3223b2e.js";import"./tweakpane.4e5e1789.js";class Ce{constructor(t,l,a){this.variables=[],this.currentTextureIndex=0;let i=V;const s=new ne,o=new te;o.position.z=1;const f={passThruTexture:{value:null}},u=I(P(),f),p=new ie(new ae(2,2),u);s.add(p),this.setDataType=function(n){return i=n,this},this.addVariable=function(n,e,r){const m=this.createShaderMaterial(e),c={name:n,initialValueTexture:r,material:m,dependencies:null,renderTargets:[],wrapS:null,wrapT:null,minFilter:D,magFilter:D};return this.variables.push(c),c},this.setVariableDependencies=function(n,e){n.dependencies=e},this.init=function(){if(a.capabilities.isWebGL2===!1&&a.extensions.has("OES_texture_float")===!1)return"No OES_texture_float support for float textures.";if(a.capabilities.maxVertexTextures===0)return"No support for vertex shader textures.";for(let n=0;n<this.variables.length;n++){const e=this.variables[n];e.renderTargets[0]=this.createRenderTarget(t,l,e.wrapS,e.wrapT,e.minFilter,e.magFilter),e.renderTargets[1]=this.createRenderTarget(t,l,e.wrapS,e.wrapT,e.minFilter,e.magFilter),this.renderTexture(e.initialValueTexture,e.renderTargets[0]),this.renderTexture(e.initialValueTexture,e.renderTargets[1]);const r=e.material,m=r.uniforms;if(e.dependencies!==null)for(let c=0;c<e.dependencies.length;c++){const d=e.dependencies[c];if(d.name!==e.name){let g=!1;for(let T=0;T<this.variables.length;T++)if(d.name===this.variables[T].name){g=!0;break}if(!g)return"Variable dependency not found. Variable="+e.name+", dependency="+d.name}m[d.name]={value:null},r.fragmentShader="\nuniform sampler2D "+d.name+";\n"+r.fragmentShader}}return this.currentTextureIndex=0,null},this.compute=function(){const n=this.currentTextureIndex,e=this.currentTextureIndex===0?1:0;for(let r=0,m=this.variables.length;r<m;r++){const c=this.variables[r];if(c.dependencies!==null){const d=c.material.uniforms;for(let g=0,T=c.dependencies.length;g<T;g++){const z=c.dependencies[g];d[z.name].value=z.renderTargets[n].texture}}this.doRenderTarget(c.material,c.renderTargets[e])}this.currentTextureIndex=e},this.getCurrentRenderTarget=function(n){return n.renderTargets[this.currentTextureIndex]},this.getAlternateRenderTarget=function(n){return n.renderTargets[this.currentTextureIndex===0?1:0]},this.dispose=function(){p.geometry.dispose(),p.material.dispose();const n=this.variables;for(let e=0;e<n.length;e++){const r=n[e];r.initialValueTexture&&r.initialValueTexture.dispose();const m=r.renderTargets;for(let c=0;c<m.length;c++)m[c].dispose()}};function y(n){n.defines.resolution="vec2( "+t.toFixed(1)+", "+l.toFixed(1)+" )"}this.addResolutionDefine=y;function I(n,e){e=e||{};const r=new j({name:"GPUComputationShader",uniforms:e,vertexShader:A(),fragmentShader:n});return y(r),r}this.createShaderMaterial=I,this.createRenderTarget=function(n,e,r,m,c,d){return n=n||t,e=e||l,r=r||B,m=m||B,c=c||D,d=d||D,new oe(n,e,{wrapS:r,wrapT:m,minFilter:c,magFilter:d,format:F,type:i,depthBuffer:!1})},this.createTexture=function(){const n=new Float32Array(t*l*4),e=new re(n,t,l,F,V);return e.needsUpdate=!0,e},this.renderTexture=function(n,e){f.passThruTexture.value=n,this.doRenderTarget(u,e),f.passThruTexture.value=null},this.doRenderTarget=function(n,e){const r=a.getRenderTarget(),m=a.xr.enabled,c=a.shadowMap.autoUpdate;a.xr.enabled=!1,a.shadowMap.autoUpdate=!1,p.material=n,a.setRenderTarget(e),a.render(s,o),p.material=u,a.xr.enabled=m,a.shadowMap.autoUpdate=c,a.setRenderTarget(r)};function A(){return"void main()	{\n\n	gl_Position = vec4( position, 1.0 );\n\n}\n"}function P(){return"uniform sampler2D passThruTexture;\n\nvoid main() {\n\n	vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n	gl_FragColor = texture2D( passThruTexture, uv );\n\n}\n"}}}function G(C){let t=[];a(C);const l=new k;return{setColors:a,getColorAt:i};function a(s){t=[],s.forEach(o=>{t.push(new k(o))})}function i(s){const o=Math.max(0,Math.min(1,s))*(C.length-1),f=Math.floor(o),u=t[f];if(f>=C.length-1)return u.clone();const p=o-f,y=t[f+1];return l.r=u.r+p*(y.r-u.r),l.g=u.g+p*(y.g-u.g),l.b=u.b+p*(y.b-u.b),l.clone()}}const ze='//\n// psrdnoise3.glsl\n//\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\n// and Ian McEwan (ijm567@gmail.com)\n// Version 2021-12-02, published under the MIT license (see below)\n//\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the "Software"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n//\n\n//\n// Periodic (tiling) 3-D simplex noise (tetrahedral lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n//\n// This is (yet) another variation on simplex noise. Unlike previous\n// implementations, the grid is axis-aligned to permit rectangular tiling.\n// The noise pattern can be made to tile seamlessly to any integer periods\n// up to 289 units in the x, y and z directions. Specifying a longer\n// period than 289 will result in errors in the noise field.\n//\n// This particular version of 3-D noise also implements animation by rotating\n// the generating gradient at each lattice point around a pseudo-random axis.\n// The rotating gradients give the appearance of a swirling motion, and\n// can serve a similar purpose for animation as motion along the fourth\n// dimension in 4-D noise. \n//\n// The rotating gradients in conjunction with the built-in ability to\n// compute exact analytic derivatives allow for "flow noise" effects\n// as presented by Ken Perlin and Fabrice Neyret.\n//\n\n// Use Perlin\'s rotated grid instead of the new tiling grid?\n// Enabling this adds about 1% to the execution time and\n// requires all periods to be multiples of 3. Other\n// integer periods can be specified, but when not evenly\n// divisible by 3, the actual period will be 3 times longer.\n// Take care not to overstep the maximum allowed period (288).\n//#define PERLINGRID\n\n// Enable faster gradient rotations?\n// Enabling this saves about 10% on execution time,\n// but the function will not run faster for alpha = 0.\n//#define FASTROTATION\n\n\n// Permutation polynomial for the hash value\nvec4 permute(vec4 x) {\n     vec4 xm = mod(x, 289.0);\n     return mod(((xm*34.0)+10.0)*xm, 289.0);\n}\n\n//\n// 3-D tiling simplex noise with rotating gradients and first order\n// analytical derivatives.\n// "vec3 x" is the point (x,y,z) to evaluate\n// "vec3 period" is the desired periods along x,y,z, up to 289.\n// (If Perlin\'s grid is used, multiples of 3 up to 288 are allowed.)\n// "float alpha" is the rotation (in radians) for the swirling gradients.\n// The "float" return value is the noise value, and\n// the "out vec3 gradient" argument returns the x,y,z partial derivatives.\n//\n// The function executes 15-20% faster if alpha is constant == 0.0\n// across all fragments being executed in parallel.\n// (This speedup will not happen if FASTROTATION is enabled. Do not specify\n// FASTROTATION if you are not actually going to use the rotation.)\n//\n// Setting any period to 0.0 or a negative value will skip the periodic\n// wrap for that dimension. Setting all periods to 0.0 makes the function\n// execute 10-15% faster.\n//\n// Not using the return value for the gradient will make the compiler\n// eliminate the code for computing it. This speeds up the function by\n// around 10%.\n//\nfloat psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)\n{\n\n#ifndef PERLINGRID\n  // Transformation matrices for the axis-aligned simplex grid\n  const mat3 M = mat3(0.0, 1.0, 1.0,\n                      1.0, 0.0, 1.0,\n                      1.0, 1.0, 0.0);\n\n  const mat3 Mi = mat3(-0.5, 0.5, 0.5,\n                        0.5,-0.5, 0.5,\n                        0.5, 0.5,-0.5);\n#endif\n\n  vec3 uvw;\n\n  // Transform to simplex space (tetrahedral grid)\n#ifndef PERLINGRID\n  // Use matrix multiplication, let the compiler optimise\n  uvw = M * x;\n#else\n  // Optimised transformation to uvw (slightly faster than\n  // the equivalent matrix multiplication on most platforms)\n  uvw = x + dot(x, vec3(1.0/3.0));\n#endif\n\n  // Determine which simplex we\'re in, i0 is the "base corner"\n  vec3 i0 = floor(uvw);\n  vec3 f0 = fract(uvw); // coords within "skewed cube"\n\n  // To determine which simplex corners are closest, rank order the\n  // magnitudes of u,v,w, resolving ties in priority order u,v,w,\n  // and traverse the four corners from largest to smallest magnitude.\n  // o1, o2 are offsets in simplex space to the 2nd and 3rd corners.\n  vec3 g_ = step(f0.xyx, f0.yzz); // Makes comparison "less-than"\n  vec3 l_ = 1.0 - g_;             // complement is "greater-or-equal"\n  vec3 g = vec3(l_.z, g_.xy);\n  vec3 l = vec3(l_.xy, g_.z);\n  vec3 o1 = min( g, l );\n  vec3 o2 = max( g, l );\n\n  // Enumerate the remaining simplex corners\n  vec3 i1 = i0 + o1;\n  vec3 i2 = i0 + o2;\n  vec3 i3 = i0 + vec3(1.0);\n\n  vec3 v0, v1, v2, v3;\n\n  // Transform the corners back to texture space\n#ifndef PERLINGRID\n  v0 = Mi * i0;\n  v1 = Mi * i1;\n  v2 = Mi * i2;\n  v3 = Mi * i3;\n#else\n  // Optimised transformation (mostly slightly faster than a matrix)\n  v0 = i0 - dot(i0, vec3(1.0/6.0));\n  v1 = i1 - dot(i1, vec3(1.0/6.0));\n  v2 = i2 - dot(i2, vec3(1.0/6.0));\n  v3 = i3 - dot(i3, vec3(1.0/6.0));\n#endif\n\n  // Compute vectors to each of the simplex corners\n  vec3 x0 = x - v0;\n  vec3 x1 = x - v1;\n  vec3 x2 = x - v2;\n  vec3 x3 = x - v3;\n\n  if(any(greaterThan(period, vec3(0.0)))) {\n    // Wrap to periods and transform back to simplex space\n    vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);\n    vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);\n    vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);\n	// Wrap to periods where specified\n	if(period.x > 0.0) vx = mod(vx, period.x);\n	if(period.y > 0.0) vy = mod(vy, period.y);\n	if(period.z > 0.0) vz = mod(vz, period.z);\n    // Transform back\n#ifndef PERLINGRID\n    i0 = M * vec3(vx.x, vy.x, vz.x);\n    i1 = M * vec3(vx.y, vy.y, vz.y);\n    i2 = M * vec3(vx.z, vy.z, vz.z);\n    i3 = M * vec3(vx.w, vy.w, vz.w);\n#else\n    v0 = vec3(vx.x, vy.x, vz.x);\n    v1 = vec3(vx.y, vy.y, vz.y);\n    v2 = vec3(vx.z, vy.z, vz.z);\n    v3 = vec3(vx.w, vy.w, vz.w);\n    // Transform wrapped coordinates back to uvw\n    i0 = v0 + dot(v0, vec3(1.0/3.0));\n    i1 = v1 + dot(v1, vec3(1.0/3.0));\n    i2 = v2 + dot(v2, vec3(1.0/3.0));\n    i3 = v3 + dot(v3, vec3(1.0/3.0));\n#endif\n	// Fix rounding errors\n    i0 = floor(i0 + 0.5);\n    i1 = floor(i1 + 0.5);\n    i2 = floor(i2 + 0.5);\n    i3 = floor(i3 + 0.5);\n  }\n\n  // Compute one pseudo-random hash value for each corner\n  vec4 hash = permute( permute( permute( \n              vec4(i0.z, i1.z, i2.z, i3.z ))\n            + vec4(i0.y, i1.y, i2.y, i3.y ))\n            + vec4(i0.x, i1.x, i2.x, i3.x ));\n\n  // Compute generating gradients from a Fibonacci spiral on the unit sphere\n  vec4 theta = hash * 3.883222077;  // 2*pi/golden ratio\n  vec4 sz    = hash * -0.006920415 + 0.996539792; // 1-(hash+0.5)*2/289\n  vec4 psi   = hash * 0.108705628 ; // 10*pi/289, chosen to avoid correlation\n\n  vec4 Ct = cos(theta);\n  vec4 St = sin(theta);\n  vec4 sz_prime = sqrt( 1.0 - sz*sz ); // s is a point on a unit fib-sphere\n\n  vec4 gx, gy, gz;\n\n  // Rotate gradients by angle alpha around a pseudo-random ortogonal axis\n#ifdef FASTROTATION\n  // Fast algorithm, but without dynamic shortcut for alpha = 0\n  vec4 qx = St;         // q\' = norm ( cross(s, n) )  on the equator\n  vec4 qy = -Ct; \n  vec4 qz = vec4(0.0);\n\n  vec4 px =  sz * qy;   // p\' = cross(q, s)\n  vec4 py = -sz * qx;\n  vec4 pz = sz_prime;\n\n  psi += alpha;         // psi and alpha in the same plane\n  vec4 Sa = sin(psi);\n  vec4 Ca = cos(psi);\n\n  gx = Ca * px + Sa * qx;\n  gy = Ca * py + Sa * qy;\n  gz = Ca * pz + Sa * qz;\n#else\n  // Slightly slower algorithm, but with g = s for alpha = 0, and a\n  // useful conditional speedup for alpha = 0 across all fragments\n  if(alpha != 0.0) {\n    vec4 Sp = sin(psi);          // q\' from psi on equator\n    vec4 Cp = cos(psi);\n\n    vec4 px = Ct * sz_prime;     // px = sx\n    vec4 py = St * sz_prime;     // py = sy\n    vec4 pz = sz;\n\n    vec4 Ctp = St*Sp - Ct*Cp;    // q = (rotate( cross(s,n), dot(s,n))(q\')\n    vec4 qx = mix( Ctp*St, Sp, sz);\n    vec4 qy = mix(-Ctp*Ct, Cp, sz);\n    vec4 qz = -(py*Cp + px*Sp);\n\n    vec4 Sa = vec4(sin(alpha));       // psi and alpha in different planes\n    vec4 Ca = vec4(cos(alpha));\n\n    gx = Ca * px + Sa * qx;\n    gy = Ca * py + Sa * qy;\n    gz = Ca * pz + Sa * qz;\n  }\n  else {\n    gx = Ct * sz_prime;  // alpha = 0, use s directly as gradient\n    gy = St * sz_prime;\n    gz = sz;  \n  }\n#endif\n\n  // Reorganize for dot products below\n  vec3 g0 = vec3(gx.x, gy.x, gz.x);\n  vec3 g1 = vec3(gx.y, gy.y, gz.y);\n  vec3 g2 = vec3(gx.z, gy.z, gz.z);\n  vec3 g3 = vec3(gx.w, gy.w, gz.w);\n\n  // Radial decay with distance from each simplex corner\n  vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  w = max(w, 0.0);\n  vec4 w2 = w * w;\n  vec4 w3 = w2 * w;\n\n  // The value of the linear ramp from each of the corners\n  vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));\n\n  // Multiply by the radial decay and sum up the noise value\n  float n = dot(w3, gdotx);\n\n  // Compute the first order partial derivatives\n  vec4 dw = -6.0 * w2 * gdotx;\n  vec3 dn0 = w3.x * g0 + dw.x * x0;\n  vec3 dn1 = w3.y * g1 + dw.y * x1;\n  vec3 dn2 = w3.z * g2 + dw.z * x2;\n  vec3 dn3 = w3.w * g3 + dw.w * x3;\n  gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);\n\n  // Scale the return value to fit nicely into the range [-1,1]\n  return 39.5 * n;\n}',{randFloat:W,randFloatSpread:M}=O,Re={gpgpuSize:512,colors:[1395874,6328575],color:0,velocity:.25,coordScale:.5,noiseIntensity:.001,noiseTimeCoef:.25,pointSize:10,pointDecay:.001,opacity:1};function Ie(C,t={}){const l={...Re,...t},a=l.gpgpuSize,i=a*a;let s,o,f,u,p;const y={value:0},I={value:l.velocity},A={value:l.coordScale},P={value:l.noiseIntensity},n={value:l.pointSize},e={value:l.pointDecay},r={value:l.opacity},m={value:new N},d={uTime:y,uVelocity:I,uCoordScale:A,uNoiseIntensity:P,uPointSize:n,uPointDecay:e,uOpacity:r,uOrigin:m,uNormalMap:{value:null}};let g,T,z;Q(C),J();const K=new N;return{config:l,mesh:z,origin:K,uniforms:d,update:$,updateColors:Y};function $(x){y.value+=x.delta*l.noiseTimeCoef,s.compute(),T.uniforms.texturePosition.value=s.getCurrentRenderTarget(p).texture,T.uniforms.textureVelocity.value=s.getCurrentRenderTarget(u).texture}function Q(x){s=new Ce(a,a,x),x.capabilities.isWebGL2||s.setDataType(se),o=s.createTexture(),f=s.createTexture(),s.createTexture(),Z(o,f),u=s.addVariable("textureVelocity","\n      ".concat(ze,"\n      uniform float uTime;\n      uniform float uCoordScale;\n      uniform float uNoiseIntensity;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        if (pos.w < 0.0) {\n          vel.x = 0.0;\n          vel.y = 0.0;\n          vel.z = 0.0;\n        } else {\n          vec3 grad;\n          float n = psrdnoise(pos.xyz * uCoordScale, vec3(0.0), uTime, grad);\n          vel.xyz += pos.w * grad * uNoiseIntensity * pos.w;\n        }\n        gl_FragColor = vel;\n      }\n    "),f),p=s.addVariable("texturePosition","\n      uniform float uVelocity;\n      uniform float uPointDecay;\n      uniform vec3 uOrigin;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        if (pos.w < 0.0) { pos.w = vel.w; }\n        pos.w -= uPointDecay;\n        if (pos.w < 0.0) {\n          pos.xyz = uOrigin.xyz;\n        } else {\n          pos.xyz += uVelocity * vel.xyz;\n        }\n        gl_FragColor = pos;\n      }\n    ",o),s.setVariableDependencies(u,[p,u]),s.setVariableDependencies(p,[p,u]),Object.keys(d).forEach(v=>{u.material.uniforms[v]=d[v],p.material.uniforms[v]=d[v]});const S=s.init();S!==null&&console.error(S)}function J(){const x={value:null};Se("/textures/sphere_normal.jpg").then(h=>{h.flipY=!1,x.value=h}),g=new le;const S=new Float32Array(i*3),v=new Float32Array(i*2),w=new Float32Array(i*3),b=new Float32Array(i).fill(0).map(()=>O.randFloat(.5,1));for(let h=0;h<i*3;h+=3)S[h]=0,S[h+1]=0,S[h+2]=0;let _=0;for(let h=0;h<a;h++)for(let R=0;R<a;R++)v[_++]=R/(a-1),v[_++]=h/(a-1);const X=G(l.colors);for(let h=0;h<i*3;h+=3){const R=X.getColorAt(Math.random());w[h]=R.r,w[h+1]=R.g,w[h+2]=R.b}g.setAttribute("position",new E(S,3)),g.setAttribute("uv",new E(v,2)),g.setAttribute("color",new E(w,3)),g.setAttribute("scale",new E(b,1));const ee=ue.lights_fragment_begin.replaceAll("RE_Direct( directLight, geometry, material, reflectedLight );","\n        RE_Direct( directLight, geometry, material, reflectedLight );\n        #if defined( SUBSURFACE )\n          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\n        #endif\n      ");T=new j({lights:!0,transparent:!0,vertexColors:!0,uniforms:{texturePosition:{value:null},textureVelocity:{value:null},uPointSize:n,uOpacity:r,uNormalMap:x,ambientLightColor:{value:null},lightProbe:{value:null},directionalLights:{value:null},directionalLightShadows:{value:null},spotLights:{value:null},spotLightShadows:{value:null},rectAreaLights:{value:null},ltc_1:{value:null},ltc_2:{value:null},pointLights:{value:null},pointLightShadows:{value:null},hemisphereLights:{value:null},directionalShadowMap:{value:null},directionalShadowMatrix:{value:null},spotShadowMap:{value:null},spotLightMatrix:{value:null},spotLightMap:{value:null},pointShadowMap:{value:null},pointShadowMatrix:{value:null},thicknessColor:{value:new k(16777215)},thicknessDistortion:{value:.5},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:5},thicknessScale:{value:10}},vertexShader:"\n        uniform sampler2D texturePosition;\n        uniform sampler2D textureVelocity;\n        uniform float uPointSize;\n        attribute float scale;\n        varying vec3 vCol;\n        varying vec3 vViewPosition;\n\n        varying vec4 vPos;\n        // varying vec4 vVel;\n\n        void main() {\n          vCol = color;\n          vPos = texture2D(texturePosition, uv);\n          // vVel = texture2D(textureVelocity, uv);\n          vec4 mvPosition = modelViewMatrix * vec4(vPos.xyz, 1.0);\n          vViewPosition = - mvPosition.xyz;\n          gl_Position = projectionMatrix * mvPosition;\n          gl_PointSize = scale * vPos.w * uPointSize * ( 10.0 / -mvPosition.z );\n        }\n      ",fragmentShader:"\n        #define SUBSURFACE\n\n        uniform float uOpacity;\n        uniform vec3 uColor;\n        uniform sampler2D uNormalMap;\n        uniform mat3 normalMatrix;\n\n        uniform float thicknessPower;\n        uniform float thicknessScale;\n        uniform float thicknessDistortion;\n        uniform float thicknessAmbient;\n        uniform float thicknessAttenuation;\n        uniform vec3 thicknessColor;\n\n        varying vec4 vPos;\n        // varying vec4 vVel;\n        varying vec3 vCol;\n\n        #include <common>\n        #include <bsdfs>\n        #include <lights_pars_begin>\n        #include <lights_phong_pars_fragment>\n\n        void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\n          #ifdef USE_COLOR\n            vec3 thickness = vCol.rgb * thicknessColor;\n          #else\n            vec3 thickness = thicknessColor;\n          #endif\n          vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\n          float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n          vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\n          reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n        }\n\n        void main() {\n          float dist = length(gl_PointCoord - 0.5);\n          if (dist > 0.49) discard;\n\n          ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n          vec3 totalEmissiveRadiance = vec3(0, 0, 0) ; // vCol.rgb;\n\n          vec2 vUv = gl_PointCoord;\n          vec3 normal = texture2D(uNormalMap, gl_PointCoord).xyz * 2.0 - 1.0;\n          normal = normalize( normal );\n\n          BlinnPhongMaterial material;\n          material.diffuseColor = vCol.rgb;\n          material.specularColor = vec3(0.0, 0.0, 0.0);\n          material.specularShininess = 30.0;\n          material.specularStrength = 1.0;\n\n          ".concat(ee,"\n          // #include <lights_fragment_begin>\n          #include <lights_fragment_end>\n          vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n          gl_FragColor = vec4(outgoingLight, uOpacity);\n        }\n      ")}),z=new ce(g,T)}function Y(){const x=g.getAttribute("color"),S=G(l.colors);for(let v=0;v<i*3;v+=3){const w=S.getColorAt(Math.random());x.array[v]=w.r,x.array[v+1]=w.g,x.array[v+2]=w.b}x.needsUpdate=!0}function Z(x,S){const v=x.image.data,w=S.image.data;for(let b=0,_=v.length;b<_;b+=4)v[b+0]=M(1),v[b+1]=M(1),v[b+2]=M(1),v[b+3]=W(.001,1),w[b+0]=0,w[b+1]=0,w[b+2]=0,w[b+3]=W(.5,1)}}const Pe={class:"test"},Ae=be("canvas",{id:"webgl-test"},null,-1),_e=[Ae],ke={__name:"index",setup(C){let t,l;const a=new de;let i,s,o;const f={followMouse:!1,pause:!1},u=new ve,p=new pe,y=new N;fe(()=>{xe(()=>{t=me({id:"webgl-test",size:"window",postprocessing:{effects:[{EffectClass:he,args:[{mipmapBlur:!0,luminanceThreshold:0,luminanceSmoothing:.05,intensity:2,radius:.25}]}]}}),t.cameraMaxAspect=1.7,t.camera.position.set(0,0,10),t.camera.lookAt(0,0,0),l=ge(t.camera,t.canvas);const e=10,r=2,m=new L(6328575,e);m.position.set(-1,0,0).multiplyScalar(r),a.add(m);const c=new L(16748640,e);c.position.set(1,0,0).multiplyScalar(r),a.add(c);const d=new L(6356880,e);d.position.set(0,-1,0).multiplyScalar(r),a.add(d);const g=new L(16736511,e);g.position.set(0,1,0).multiplyScalar(r),a.add(g),t.scene.add(a);const T=O.clamp(U().query.gpgpuSize||512,256,4096),z=O.clamp(U().query.pointSize||10,.1,20);i=Ie(t.renderer,{gpgpuSize:T,pointSize:z}),t.scene.add(i.mesh),I(),t.on("update",P)}),q().on("device.pointermove",A),q().on("device.resize",n)});function I(){s=H({title:"Postprocessing"}),s.addBinding(t.postprocessing,"bloomIntensity",{min:0,max:10,step:.01}),s.addBinding(t.postprocessing,"bloomRadius",{min:0,max:1,step:.001}),s.addBinding(t.postprocessing,"bloomLuminanceThreshold",{min:0,max:1,step:.001}),s.addBinding(t.postprocessing,"bloomLuminanceSmoothing",{min:0,max:1,step:.001}),o=H({title:"Misc",expanded:!1}),o.addBinding(f,"pause"),o.addBinding(f,"followMouse").on("change",({value:e})=>{e||y.set(0,0,0)}),o.addBinding({color1:i.config.colors[0]},"color1",{view:"color"}).on("change",({value:e})=>{i.config.colors[0]=e,i.updateColors()}),o.addBinding({color2:i.config.colors[1]},"color2",{view:"color"}).on("change",({value:e})=>{i.config.colors[1]=e,i.updateColors()}),o.addBinding(i.uniforms.uPointSize,"value",{label:"size",step:.001,min:.1,max:30}),o.addBinding(i.uniforms.uVelocity,"value",{label:"velocity",step:1e-4,min:0,max:1}),o.addBinding(i.uniforms.uPointDecay,"value",{label:"decay",step:1e-5,min:1e-4,max:.01}),o.addBinding(i.config,"noiseTimeCoef",{label:"noise time",step:.001,min:0,max:1}),o.addBinding(i.uniforms.uCoordScale,"value",{label:"noise scale",step:.001,min:0,max:2}),o.addBinding(i.uniforms.uNoiseIntensity,"value",{label:"noise intensity",step:1e-4,min:0,max:.01}),o.addBinding(i.mesh.material.uniforms.thicknessDistortion,"value",{label:"thicknessDistortion",step:1e-4,min:0,max:1}),o.addBinding(i.mesh.material.uniforms.thicknessAmbient,"value",{label:"thicknessAmbient",step:1e-4,min:0,max:1}),o.addBinding(i.mesh.material.uniforms.thicknessAttenuation,"value",{label:"thicknessAttenuation",step:1e-4,min:0,max:1}),o.addBinding(i.mesh.material.uniforms.thicknessPower,"value",{label:"thicknessPower",step:1e-4,min:0,max:50}),o.addBinding(i.mesh.material.uniforms.thicknessScale,"value",{label:"thicknessScale",step:1e-4,min:0,max:50}),o.addBinding({thicknessColor:i.mesh.material.uniforms.thicknessColor.value.getHex()},"thicknessColor",{view:"color"}).on("change",({value:e})=>{i.mesh.material.uniforms.thicknessColor.value.set(e)})}function A(e){f.followMouse&&(t.camera.getWorldDirection(p.normal),u.setFromCamera(e.pointer.relative,t.camera),u.ray.intersectPlane(p,y),i.uniforms.uOrigin.value.copy(y))}function P(e){l.update(),!f.pause&&(a.rotation.x+=e.delta*.4,a.rotation.y+=e.delta*.25,a.rotation.z+=e.delta*.65,i.update(e))}function n(){t&&t.resize()}return ye(()=>{s==null||s.dispose(),o==null||o.dispose(),l&&l.dispose(),t&&(t.off("update",P),t.off("resize",n),t.dispose())}),(e,r)=>(we(),Te("div",Pe,_e))}};export{ke as default};
