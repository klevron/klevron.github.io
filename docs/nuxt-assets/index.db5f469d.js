import{V as w,B as C,M as v,a as p,S as P,C as M,P as z,b as B,O as A,u as D,c as R,d as f,e as E}from"./camera.778392bf.js";import{o as U,Q as O,F as x,R as k,S as F,j as T,k as I,l as V}from"./entry.9e1091cc.js";import{u as L}from"./tweakpane.8044cfb2.js";import{l as N}from"./assets.e623ba5f.js";import"./tweakpane.4e5e1789.js";const j={count:512*512,pointSize:1,opacity:1};function H(h={}){const e={...j,...h},s=e.count;let n,i,l;m();const o=new w;return{config:e,mesh:l,origin:o,update:d};function d(c){}function m(){const c={value:null};N("/textures/sphere_normal.jpg").then(a=>{a.flipY=!1,c.value=a}),n=new C;const u=new Float32Array(s*3),t=new Float32Array(s).fill(0).map(()=>v.randFloat(.1,1)),r=new Float32Array(s*4);for(let a=0;a<s*3;a+=3)q().toArray(u,a);for(let a=0;a<s*4;a+=4)r[a]=Math.random(),r[a+1]=Math.random(),r[a+2]=Math.random(),r[a+3]=1;n.setAttribute("position",new p(u,3)),n.setAttribute("color",new p(r,4)),n.setAttribute("scale",new p(t,1));const g=B.lights_fragment_begin.replaceAll("RE_Direct( directLight, geometry, material, reflectedLight );","\n        RE_Direct( directLight, geometry, material, reflectedLight );\n        #if defined( SUBSURFACE )\n          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\n        #endif\n      ");i=new P({transparent:!0,vertexColors:!0,lights:!0,uniforms:{uPointSize:{value:e.pointSize},uOpacity:{value:e.opacity},uNormalMap:c,ambientLightColor:{value:null},lightProbe:{value:null},directionalLights:{value:null},directionalLightShadows:{value:null},spotLights:{value:null},spotLightShadows:{value:null},rectAreaLights:{value:null},ltc_1:{value:null},ltc_2:{value:null},pointLights:{value:null},pointLightShadows:{value:null},hemisphereLights:{value:null},directionalShadowMap:{value:null},directionalShadowMatrix:{value:null},spotShadowMap:{value:null},spotLightMatrix:{value:null},spotLightMap:{value:null},pointShadowMap:{value:null},pointShadowMatrix:{value:null},thicknessColor:{value:new M(16777215)},thicknessDistortion:{value:.5},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:2},thicknessScale:{value:10}},vertexShader:"\n        uniform float uPointSize;\n        attribute float scale;\n        varying vec4 vCol;\n        varying vec3 vViewPosition;\n\n        void main() {\n          vCol = color;\n          vec3 transformed = vec3(position);\n          vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n          vViewPosition = - mvPosition.xyz;\n          gl_Position = projectionMatrix * mvPosition;\n          gl_PointSize = scale * uPointSize * ( 10.0 / -mvPosition.z );\n        }\n      ",fragmentShader:"\n        #define SUBSURFACE\n\n        uniform float uOpacity;\n        uniform sampler2D uNormalMap;\n        uniform mat3 normalMatrix;\n\n        uniform float thicknessPower;\n        uniform float thicknessScale;\n        uniform float thicknessDistortion;\n        uniform float thicknessAmbient;\n        uniform float thicknessAttenuation;\n        uniform vec3 thicknessColor;\n\n        varying vec4 vCol;\n\n        #include <common>\n        #include <bsdfs>\n        #include <lights_pars_begin>\n        #include <lights_phong_pars_fragment>\n\n        void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\n          #ifdef USE_COLOR\n            vec3 thickness = vCol.rgb * thicknessColor;\n          #else\n            vec3 thickness = thicknessColor;\n          #endif\n          vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\n          float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n          vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\n          reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n        }\n\n        void main() {\n          float dist = length(gl_PointCoord - 0.5);\n          if (dist > 0.49) discard;\n\n          ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n          vec3 totalEmissiveRadiance = vec3(0, 0, 0) ; // vCol.rgb;\n\n          vec2 vUv = gl_PointCoord;\n          vec3 normal = texture2D(uNormalMap, gl_PointCoord).xyz * 2.0 - 1.0;\n          normal = normalize( normal );\n\n          BlinnPhongMaterial material;\n          material.diffuseColor = vCol.rgb;\n          material.specularColor = vec3(0.0, 0.0, 0.0);\n          material.specularShininess = 30.0;\n          material.specularStrength = 1.0;\n\n          ".concat(g,"\n          // #include <lights_fragment_begin>\n          #include <lights_fragment_end>\n          vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n          gl_FragColor = vec4(outgoingLight, uOpacity);\n        }\n      ")}),l=new z(n,i)}}function q(){const h=Math.random(),e=Math.random(),s=h*2*Math.PI,n=Math.acos(2*e-1),i=Math.cbrt(Math.random()),l=Math.sin(s),o=Math.cos(s),d=Math.sin(n),m=Math.cos(n),c=i*d*o,u=i*d*l,t=i*m;return new w(c,u,t)}const G={class:"test"},Q=V("canvas",{id:"webgl-test"},null,-1),Y=[Q],Z={__name:"index",setup(h){let e,s;const n=new A;let i,l,o;U(()=>{O(async()=>{e=D({id:"webgl-test",size:"window",alpha:!0,postprocessing:{effects:[{EffectClass:E,args:[{mipmapBlur:!0,luminanceThreshold:0,luminanceSmoothing:.05,intensity:2,radius:.25}]}]}}),e.cameraMaxAspect=1.7,e.camera.position.set(0,0,2),e.camera.lookAt(0,0,0),s=R(e.camera,e.canvas);const t=.5,r=.5,g=new f(6328575,t);g.position.set(-1,0,0).multiplyScalar(r),n.add(g);const a=new f(16748640,t);a.position.set(1,0,0).multiplyScalar(r),n.add(a);const _=new f(6356880,t);_.position.set(0,-1,0).multiplyScalar(r),n.add(_);const S=new f(16736511,t);S.position.set(0,1,0).multiplyScalar(r),n.add(S),e.scene.add(n);const y=v.clamp(x().query.count||262144,256,4194304),b=v.clamp(x().query.pointSize||1,.1,10);i=H({count:y,pointSize:b}),e.scene.add(i.mesh),d(),e.on("update",c)}),k().on("device.pointermove",m),k().on("device.resize",u)});function d(){l=L({title:"Postprocessing"}),l.addBinding(e.postprocessing,"bloomIntensity",{min:0,max:10,step:.01}),l.addBinding(e.postprocessing,"bloomRadius",{min:0,max:1,step:.001}),l.addBinding(e.postprocessing,"bloomLuminanceThreshold",{min:0,max:1,step:.001}),l.addBinding(e.postprocessing,"bloomLuminanceSmoothing",{min:0,max:1,step:.001}),o=L({title:"Misc",expanded:!1}),o.addBinding(n.scale,"x",{label:"lights scale",step:.1,min:0,max:2}).on("change",({value:t})=>{n.scale.y=t,n.scale.z=t}),o.addBinding(i.mesh.scale,"x",{label:"scale",step:.1,min:0,max:2}).on("change",({value:t})=>{i.mesh.scale.y=t,i.mesh.scale.z=t}),o.addBinding(i.mesh.material.uniforms.uPointSize,"value",{label:"size",step:1e-4,min:.1,max:10}),o.addBinding(i.mesh.material.uniforms.thicknessDistortion,"value",{label:"thicknessDistortion",step:1e-4,min:0,max:1}),o.addBinding(i.mesh.material.uniforms.thicknessAmbient,"value",{label:"thicknessAmbient",step:1e-4,min:0,max:1}),o.addBinding(i.mesh.material.uniforms.thicknessAttenuation,"value",{label:"thicknessAttenuation",step:1e-4,min:0,max:1}),o.addBinding(i.mesh.material.uniforms.thicknessPower,"value",{label:"thicknessPower",step:1e-4,min:0,max:50}),o.addBinding(i.mesh.material.uniforms.thicknessScale,"value",{label:"thicknessScale",step:1e-4,min:0,max:50}),o.addBinding({thicknessColor:i.mesh.material.uniforms.thicknessColor.value.getHex()},"thicknessColor",{view:"color"}).on("change",({value:t})=>{i.mesh.material.uniforms.thicknessColor.value.set(t)})}function m(t){}function c(t){s.update(),i.mesh.rotation.x+=t.delta*.01,i.mesh.rotation.y+=t.delta*.016,i.mesh.rotation.z+=t.delta*.007,n.rotation.x+=t.delta*.4,n.rotation.y+=t.delta*.25,n.rotation.z+=t.delta*.65}function u(){e&&e.resize()}return F(()=>{l==null||l.dispose(),o==null||o.dispose(),s&&s.dispose(),e&&(e.off("update",c),e.off("resize",u),e.dispose())}),(t,r)=>(T(),I("div",G,Y))}};export{Z as default};
